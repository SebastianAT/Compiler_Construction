/* Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

PARSER_BEGIN(Yapl)
package yapl.compiler;

import yapl.ant.*;
import yapl.compiler.*;
import yapl.exception.*;
import yapl.impl.YAPLSymbol;
import yapl.impl.YAPLSymbolTable;
import yapl.interfaces.*;
import yapl.lib.*;

/** Simple brace matcher. */
public class  Yapl{

    private static Symboltable symboltable = new YAPLSymbolTable();
  /** Main entry point. */
  public static void main(String args[]) throws ParseException {
      Yapl parser;

      if(args.length == 0){
            System.out.println ("Reading input ...");
            parser = new Yapl(System.in);
      }
      else if(args.length == 1){
            System.out.println ("Reading the file " + args[0] + " ..." );
            try {
              parser = new Yapl(new java.io.FileInputStream(args[0]));
            }
            catch(java.io.FileNotFoundException e) {
              System.out.println ("The file " + args[0] + " was not found.");
              return;
            }
      }
      else {
            System.out.println ("You must use one of the following:");
            System.out.println ("         java <parsername>");
            System.out.println ("Or");
            System.out.println ("         java <parsername> file");
            return ;
      }
      try {
            parser.Start();
            CompilerMessage.printOK("Yapl");
      }
      catch(ParseException e){
            CompilerMessage.printError(e,"Yapl");
      }
      catch(TokenMgrError e){
            CompilerMessage.printError(e,"Yapl");
      }
      catch(YAPLException e){
          CompilerMessage.printError(e, "Yapl");
      }

  }

}

PARSER_END(Yapl)

// IGNORE WHITE SPACES
SKIP:
{
    " " | "\n" | "\r" | "\t"
}

// Reuseable Default Token
TOKEN : {
<# LETTER: (["a"-"z", "A"-"Z", "_"])> |
<# DIGIT: (["0"-"9"])> |
<# OTHERCHAR: ("+" | "-" | "*" | "/" | "." | "," | ";" | ":" | "!" | "?" | "=" | "#" | "%" | "<" | ">" | "$" | "(" | ")" | "[" | "]" | "{" | "}" | "\\" | "@" | "&" | "^" | "|")>
}

// Keywords
TOKEN : {
    < TRUE : "True" > |
    < FALSE : "False" > |
    < AND: "And" > |
    < NEW: "new" > |
    < OR: "Or" > |
    < IF : "If" > |
    < THEN : "Then" > |
    < ELSE : "Else" > |
    < ENDIF : "EndIf" > |
    < WHILE : "While" > |
    < DO : "Do" > |
    < ENDWHILE : "EndWhile" > |
    < RETURN : "Return" > |
    < WRITE : "Write" > |
    < BEGIN : "Begin" > |
    < END: "End" > |
    < INTEGER :  "int" > |
    < BOOLEAN : "bool" > |
    < VOID : "void" > |
    < CONST : "Const" > |
    < RECORD : "Record" > |
    < ENDRECORD : "EndRecord" > |
    < DECLARE : "Declare" > |
    < PROCEDURE : "Procedure" > |
    < PROGRAM : "Program" > |
    < IDENT : < LETTER > (< LETTER > | < DIGIT >)* > |
    < NUMBER: (< DIGIT >)+ > |
    < STRING: "\"" ( " " | < LETTER > | < DIGIT > | < OTHERCHAR > )* "\"" > |
	< GREATER_EQUAL: ">=" > |
	< LESS_EQUAL: "<=" > |
	< LESS: "<" > |
	< GREATER: ">" > |
	< EQUAL: "==" > |
	< UNEQUAL: "!=" > |
	< ASSIGN: ":=" > 
}

// Special Token for Comments
SPECIAL_TOKEN : {
    < COMMENT : ("/*" (~["*"] | "*" ~["/"])* "*/") >
}

// OPERATIONS
void RelOP() throws YAPLException : {Token t;}{
    t = <LESS> | t = <LESS_EQUAL> | t = <GREATER_EQUAL> | t = <GREATER>
}
void EqualOP() throws YAPLException : {Token t;}{
    t = <EQUAL> | t = <UNEQUAL>
}
void AddOP() throws YAPLException : {Token t;}{
    t = "+" | t = "-"
}
void MulOP() throws YAPLException : {Token t;}{
    t = "*" | t = "/" | t = "%"
}


// EXPRESSIONS
void Literal() throws YAPLException : {Token t;}{
    t = <TRUE> | t = <FALSE> | <NUMBER>
}
void Selector() throws YAPLException : {Token t;}{
    ( "[" Expr() "]" | "." t = <IDENT>
    {
        //TODO: Implement later, not needed in CA3
    }
    )[Selector()]
}
void ArrayLen() throws YAPLException : {Token t;}{
    "#" t = <IDENT>
    {
    Symbol s = symboltable.lookup(t.image);
    if(s.getKind() != Symbol.Variable && s.getKind() != Symbol.Parameter){
        throw new SymbolIllegalUseException(s);
    }
}
    [Selector() ]
}
void PrimaryExpr() throws YAPLException : {Token t;}{
    Literal() | "(" Expr() ")" | LOOKAHEAD(2) ProcedureCall() | t = <IDENT>
    {
    Symbol s = symboltable.lookup(t.image);
    if(s.getKind() != Symbol.Variable && s.getKind() != Symbol.Constant && s.getKind() != Symbol.Parameter){
        throw new SymbolIllegalUseException(s);
    }
}
    [Selector()] | ArrayLen()
}
void UnaryExpr() throws YAPLException : {Token t;}{
    [AddOP() ] PrimaryExpr()
}
void MulExpr() throws YAPLException :{Token t;}{
    UnaryExpr()  (MulOP()  UnaryExpr() )*
}
void AddExpr() throws YAPLException : {Token t;}{
    MulExpr() (AddOP() MulExpr() )*
}
void RelExpr() throws YAPLException : {Token t;}{
    AddExpr() [RelOP() AddExpr() ]
}
void EqualExpr() throws YAPLException : {Token t;}{
    RelExpr() [EqualOP() RelExpr() ]
}
void CondAndExpr() throws YAPLException : {Token t;}{
    EqualExpr() (<AND> EqualExpr() )*
}
void CreationExpr() throws YAPLException : {Token t;}{
    <NEW> NonArrayType() ("[" Expr() "]")*
}
void Expr() throws YAPLException : {Token t;}{
    CondAndExpr() (<OR> CondAndExpr() )* | CreationExpr()
}

//Statements
void ArgumentList() throws YAPLException : {Token t;}{
    Expr() ("," Expr() )*
}
void ProcedureCall() throws YAPLException : {Token t;}{
    t = <IDENT>
    {
    Symbol s = symboltable.lookup(t.image);
    if(s.getKind() != Symbol.Procedure){
        throw new SymbolIllegalUseException(s);
    }
}
     "(" [ArgumentList() ] ")"
}

void Assignment() throws YAPLException : {Token t;}{
    t = <IDENT>
    {
    Symbol s = symboltable.lookup(t.image);
    if(s.getKind() != Symbol.Variable && s.getKind() != Symbol.Parameter){
        throw new SymbolIllegalUseException(s);
    }
}
    [Selector() ] <ASSIGN> Expr()
}


void IfStatement() throws YAPLException : {Token t;}{
    <IF> Expr() <THEN> StatementList() [<ELSE> StatementList()] <ENDIF>
}
void WhileStatement() throws YAPLException : {Token t;}{
    <WHILE> Expr() <DO> StatementList() <ENDWHILE>
}
void ReturnStatement() throws YAPLException : {Token t;}{
    <RETURN> [Expr() ]
}
void WriteStatement() throws YAPLException : {Token t;}{
    <WRITE> <STRING>
}
void Statement() throws YAPLException : {Token t;}{
    IfStatement() | WhileStatement() | ReturnStatement() | WriteStatement() | LOOKAHEAD(2) Assignment() | ProcedureCall() | Block()
}
void StatementList() throws YAPLException : {Token t;}{
    (Statement() ";")*
}
void Block() throws YAPLException : {Token t;}{
    {
        symboltable.openScope(false);
    }
    [Decl()] <BEGIN> StatementList() <END>
    {
        //TODO: iwas wegen return
        symboltable.closeScope();
    }
}

//TYPES
void NonArrayType() throws YAPLException : {Token t;}{
    <INTEGER>  | <BOOLEAN> | t = <IDENT>
    {
    Symbol s = symboltable.lookup(t.image);
    if(s.getKind() != Symbol.Typename){
        //throw new NonArrayTypeException(s.getKind(), Symbol.Typename);
        throw new SymbolIllegalUseException(s);
    }
    }
}
void Type() throws YAPLException :{Token t;}{
    NonArrayType() ("[" "]")*
}
void ReturnType() throws YAPLException : {Token t;}{
    <VOID> | Type()
}

//DECLARATIONS
void ConstDecl() throws YAPLException : {Token t;}{
    <CONST> t = <IDENT>
    {
        Symbol s = new YAPLSymbol(t.image, Symbol.Constant);
        s.setGlobal(true);
        symboltable.addSymbol(s);
    }
    "=" Literal() ";"
}
void VarDecl() throws YAPLException : {Token t; Token t2; Symbol s;}{
    Type() t = <IDENT>
    {
        s = new YAPLSymbol(t.image, Symbol.Variable);
        symboltable.addSymbol(s);
    }
    ("," t2 = <IDENT>
    {
        s = new YAPLSymbol(t2.image, Symbol.Variable);
        symboltable.addSymbol(s);
    }
    )* ";"
}
void TypeDecl() throws YAPLException : {Token t;}{
    <RECORD> t = <IDENT>
    {
        Symbol s = new YAPLSymbol(t.image, Symbol.Typename);
        symboltable.addSymbol(s);
    }
    VarDecl() (VarDecl() )* <ENDRECORD> ";"
}
void Decl() throws YAPLException : {Token t;}{
    <DECLARE> (ConstDecl() |VarDecl() | TypeDecl() )*
}

//PARAMETERS
void FormalParam() throws YAPLException : {Token t; }{
    Type() t = <IDENT>
    {
        Symbol s = new YAPLSymbol(t.image, Symbol.Parameter);
        symboltable.addSymbol(s);
    }
}
void FormalParamList() throws YAPLException : {Token t;}{
    FormalParam() ("," FormalParam() )*
}

void Procedure() throws YAPLException : {Token t; Token x;}{
    <PROCEDURE> ReturnType() t = <IDENT>
    {
        Symbol s = new YAPLSymbol(t.image, Symbol.Procedure);
        symboltable.addSymbol(s);
        symboltable.openScope(false);
        symboltable.setParentSymbol(s);
    }
     "(" [FormalParamList()]  ")" Block() t = <IDENT>
    {
        Symbol parent = symboltable.getNearestParentSymbol(Symbol.Procedure);
        if(!parent.getName().equals(t.image)){
            throw new EndIdentifierMismatchException(parent, t.image);
        }
        symboltable.closeScope();
    }
    ";"
}
void Program() throws YAPLException : {Token t; Token x;}{
    <PROGRAM> t = <IDENT>
    {
        Symbol s = new YAPLSymbol(t.image, Symbol.Program);
        s.setGlobal(true);
        symboltable.openScope(true);
        symboltable.setParentSymbol(s);
    }
    (Decl() | Procedure() )* <BEGIN> StatementList() <END>  x = <IDENT>
     {
        if(!t.image.equals(x.image)){
            throw new EndIdentifierMismatchException(s, x.image);
        symboltable.closeScope();
     }
}
     "."
}

/** Root production. */
void Start() throws YAPLException : { Token t; } {
    (Program())*
      <EOF>
}